<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlueStacks Visual Scripting</title>
    <!-- LiteGraph.js (Local) -->
    <link rel="stylesheet" type="text/css" href="/static/css/litegraph.css">
    <script type="text/javascript" src="/static/js/litegraph.js"></script>
    <style>
        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #ddd;
            font-family: 'Segoe UI', sans-serif;
        }

        #main-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            height: 40px;
            background: #222;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
            z-index: 10;
        }

        #workspace {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }

        /* Sidebar (Left) */
        #sidebar {
            width: 200px;
            background: #2b2b2b;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
        }

        #sidebar h3 {
            margin-top: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .node-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #eee;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }

        .node-btn:hover {
            background: #505050;
            transform: translateX(2px);
            border-color: #777;
        }

        /* Colored strips for buttons */
        .btn-start {
            border-left: 3px solid #4CAF50;
        }

        .btn-click {
            border-left: 3px solid #2196F3;
        }

        .btn-swipe {
            border-left: 3px solid #2196F3;
        }

        .btn-wait {
            border-left: 3px solid #FF9800;
        }

        .btn-find {
            border-left: 3px solid #9C27B0;
        }

        .btn-loop {
            border-left: 3px solid #673AB7;
        }

        .btn-break {
            border-left: 3px solid #b71c1c;
        }

        .btn-script {
            border-left: 3px solid #E91E63;
        }

        /* Canvas (Center) */
        #editor-container {
            flex-grow: 1;
            position: relative;
            background: #111;
        }

        canvas#mycanvas {
            width: 100%;
            height: 100%;
            outline: none;
            cursor: crosshair;
        }

        /* Monitor Panel (Right) */
        #monitor-panel {
            width: 350px;
            background: #2b2b2b;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
        }

        .monitor-frame {
            background: #000;
            border: 1px solid #555;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
        }

        #screenPreview {
            max-width: 100%;
            max-height: 400px;
            display: none;
            cursor: crosshair;
        }

        /* Toolbar Buttons */
        .tool-btn {
            background: #444;
            color: #ddd;
            border: 1px solid #555;
            padding: 5px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        .tool-btn:hover {
            background: #555;
        }

        .tool-btn.primary {
            background: #2196F3;
            border-color: #1976D2;
            color: white;
        }

        .tool-btn.danger {
            background: #f44336;
            border-color: #d32f2f;
            color: white;
        }

        .tool-btn.block {
            width: 100%;
            margin-bottom: 5px;
        }

        input,
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        /* Log Console (Bottom of Monitor) */
        #logConsole {
            background: #000;
            color: #0f0;
            font-family: monospace;
            padding: 5px;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #444;
            margin-top: auto;
            /* Push to bottom */
            font-size: 12px;
            border-radius: 4px;
        }

        #coordDisplay {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            font-size: 0.8em;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 999;
        }

        /* Toast Notification */
        #toast-notification {
            position: fixed;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: top 0.3s ease-in-out;
            z-index: 2000;
            font-size: 14px;
            border: 1px solid #2196F3;
            pointer-events: none;
        }

        #toast-notification.show {
            top: 20px;
        }
    </style>
</head>

<body>
    <!-- Toast -->
    <div id="toast-notification">Notification</div>

    <div id="main-layout">
        <!-- Top Toolbar -->
        <div id="toolbar">
            <span style="font-weight:bold; margin-right:20px; font-size:16px;">BlueStacks Editor</span>
            <button class="tool-btn primary" onclick="runGraph()">â–¶ åŸ·è¡Œ (Run)</button>
            <button class="tool-btn danger" onclick="stopScript()">â¹ åœæ­¢ (Stop)</button>
            <button class="tool-btn" onclick="clearGraph()">ğŸ§¹ æ¸…ç©º (Clear)</button>
            <div style="flex-grow:1"></div>
            <input type="text" id="scriptName" placeholder="Script Name" style="width: 150px;">
            <button class="tool-btn" onclick="saveGraph()">å„²å­˜ (Save)</button>
            <select id="savedScripts" onchange="loadGraph(this.value)">
                <option value="">è¼‰å…¥è…³æœ¬...</option>
            </select>
            <button class="tool-btn danger" onclick="deleteScript()" style="padding: 5px 10px;">ğŸ—‘ï¸</button>
        </div>

        <!-- Main Workspace -->
        <div id="workspace">
            <!-- Sidebar (Left) -->
            <div id="sidebar">
                <h3>æµç¨‹æ§åˆ¶</h3>
                <button class="node-btn btn-start" onclick="addNode('bot/start')">ğŸ é–‹å§‹ (Start)</button>
                <button class="node-btn btn-wait" onclick="addNode('bot/wait')">â³ ç­‰å¾… (Wait)</button>
                <button class="node-btn btn-loop" onclick="addNode('bot/loop')">ğŸ”„ è¿´åœˆ (Loop)</button>
                <button class="node-btn btn-break" onclick="addNode('bot/loop_break')">ğŸ›‘ è·³å‡ºè¿´åœˆ (Break)</button>
                <button class="node-btn btn-script" onclick="addNode('bot/script')">ğŸ“œ å‘¼å«è…³æœ¬ (Call Script)</button>

                <h3>åŸºæœ¬å‹•ä½œ</h3>
                <button class="node-btn btn-click" onclick="addNode('bot/click')">ğŸ–±ï¸ é»æ“Š (Click)</button>
                <button class="node-btn btn-swipe" onclick="addNode('bot/swipe')">ğŸ‘† æ»‘å‹• (Swipe)</button>

                <h3>è¦–è¦ºè¾¨è­˜</h3>
                <button class="node-btn btn-find" onclick="addNode('bot/find_image')">ğŸ–¼ï¸ æ‰¾åœ– (Find Image)</button>
            </div>

            <!-- Canvas (Center) -->
            <div id="editor-container">
                <canvas id="mycanvas"></canvas>
            </div>

            <!-- Monitor (Right) -->
            <div id="monitor-panel">
                <h3>ç›£æ§èˆ‡æ“ä½œ</h3>

                <div class="monitor-frame">
                    <img id="screenPreview" src="" onmousemove="showCoords(event)" onclick="pickCoords(event)">
                    <div id="coordDisplay">X:0, Y:0</div>
                    <div id="loadingText" style="color:#666">No Image</div>
                </div>

                <button class="tool-btn block" onclick="captureScreen()">ğŸ“· æˆªåœ– (Refresh Screen)</button>
                <div style="font-size:0.8em; color:#888; margin-bottom:10px; text-align:center;">
                    é»æ“Šç•«é¢: é–å®šåº§æ¨™ / å¡«å…¥é¸å–çš„ç¯€é»
                </div>

                <hr style="width:100%; border:0; border-top:1px solid #444;">

                <button class="tool-btn block" onclick="testConnection()">ğŸ”Œ æ¸¬è©¦é€£ç·š (Test)</button>
                <button class="tool-btn block danger" onclick="shutdownServer()">âš ï¸ é—œé–‰ä¼ºæœå™¨ (Shutdown)</button>

                <h3>åŸ·è¡Œæ—¥èªŒ</h3>
                <div id="logConsole">Waiting for logs...</div>
            </div>
        </div>
    </div>

    <script>
        // Init LiteGraph
        var graph = new LGraph();
        var canvas = new LGraphCanvas("#mycanvas", graph);

        function resize() {
            var container = document.getElementById("editor-container");
            if (container) {
                canvas.resize(container.clientWidth, container.clientHeight);
                graph.setDirtyCanvas(true, true);
            }
        }
        window.addEventListener("resize", resize);
        setTimeout(resize, 100);

        // --- GLOBAL STATE ---
        var isCoordsLocked = false;
        var toastTimeout = null;

        // --- TOAST NOTIFICATION ---
        function showToast(message, type = 'info') {
            const toast = document.getElementById("toast-notification");
            toast.innerText = message;
            toast.classList.add("show");

            if (type === 'error') {
                toast.style.borderColor = '#ff4444';
            } else {
                toast.style.borderColor = '#2196F3';
            }

            if (toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toast.classList.remove("show");
            }, 2000);
        }

        // --- CUSTOM NODES ---

        // 1. Start
        function NodeStart() {
            this.addOutput("Exec", "ACTION");
            this.title = "â–¶ Start";
            this.bgcolor = "#2e7d32";
        }
        NodeStart.title = "Start";
        LiteGraph.registerNodeType("bot/start", NodeStart);

        // 2. Click
        function NodeClick() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.addInput("X", "number");
            this.addInput("Y", "number");
            this.properties = { x: 500, y: 500 };
            this.addWidget("number", "X", 500, function (v) { this.properties.x = v; }, { min: 0, max: 9999, precision: 0 });
            this.addWidget("number", "Y", 500, function (v) { this.properties.y = v; }, { min: 0, max: 9999, precision: 0 });
            this.title = "Click";
        }
        NodeClick.title = "Click";
        NodeClick.prototype.onExecute = function () { this.triggerSlot(0); }

        NodeClick.prototype.updateWidgetState = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].disabled = this.isInputConnected(1);
                if (this.widgets[1]) this.widgets[1].disabled = this.isInputConnected(2);
            }
        };

        NodeClick.prototype.onConnectionsChange = function (type, slot, connected, link_info, input_info) {
            if (type === LiteGraph.INPUT) {
                this.updateWidgetState();
            }
        };

        NodeClick.prototype.onConfigure = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].value = this.properties.x;
                if (this.widgets[1]) this.widgets[1].value = this.properties.y;
            }
            this.updateWidgetState();
        };
        LiteGraph.registerNodeType("bot/click", NodeClick);

        // 3. Swipe
        function NodeSwipe() {
            this.addInput("Exec", "ACTION");
            this.addInput("X1", "number");
            this.addInput("Y1", "number");
            this.addInput("X2", "number");
            this.addInput("Y2", "number");
            this.addOutput("Exec", "ACTION");
            this.properties = { x1: 500, y1: 800, x2: 500, y2: 200, duration: 500 };
            this.addWidget("number", "X1", 500, function (v) { this.properties.x1 = v; });
            this.addWidget("number", "Y1", 800, function (v) { this.properties.y1 = v; });
            this.addWidget("number", "X2", 500, function (v) { this.properties.x2 = v; });
            this.addWidget("number", "Y2", 200, function (v) { this.properties.y2 = v; });
            this.addWidget("number", "Time(ms)", 500, function (v) { this.properties.duration = v; });
            this.title = "Swipe";
            this.bgcolor = "#2196F3";
        }
        NodeSwipe.title = "Swipe";

        NodeSwipe.prototype.updateWidgetState = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].disabled = this.isInputConnected(1);
                if (this.widgets[1]) this.widgets[1].disabled = this.isInputConnected(2);
                if (this.widgets[2]) this.widgets[2].disabled = this.isInputConnected(3);
                if (this.widgets[3]) this.widgets[3].disabled = this.isInputConnected(4);
            }
        };

        NodeSwipe.prototype.onConnectionsChange = function (type, slot, connected, link_info, input_info) {
            if (type === LiteGraph.INPUT) {
                this.updateWidgetState();
            }
        };

        NodeSwipe.prototype.onConfigure = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].value = this.properties.x1;
                if (this.widgets[1]) this.widgets[1].value = this.properties.y1;
                if (this.widgets[2]) this.widgets[2].value = this.properties.x2;
                if (this.widgets[3]) this.widgets[3].value = this.properties.y2;
                if (this.widgets[4]) this.widgets[4].value = this.properties.duration;
            }
            this.updateWidgetState();
        };
        LiteGraph.registerNodeType("bot/swipe", NodeSwipe);

        // 4. Wait
        function NodeWait() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { seconds: 1.0 };
            this.addWidget("number", "Seconds", 1.0, function (v) { this.properties.seconds = v; }, { step: 0.1, min: 0 });
            this.title = "Wait";
        }
        NodeWait.title = "Wait";
        NodeWait.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.seconds;
            }
        };
        LiteGraph.registerNodeType("bot/wait", NodeWait);

        // 5. Loop (Updated)
        function NodeLoop() {
            var that = this;
            this.addInput("Exec", "ACTION");
            this.addOutput("Body", "ACTION");
            this.addOutput("Exit", "ACTION");
            this.properties = { count: 3 };
            this.addWidget("number", "Count (0=Inf)", 3, function (v) {
                var val = Math.max(0, Math.floor(v));
                that.properties.count = val;
                // Force UI to show integer
                if (that.widgets && that.widgets[0]) that.widgets[0].value = val;
            }, { min: 0, step: 10, precision: 0 });
            this.title = "Loop";
            this.bgcolor = "#673AB7";
        }
        NodeLoop.title = "Loop";
        NodeLoop.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.count;
            }
        };
        LiteGraph.registerNodeType("bot/loop", NodeLoop);

        // 6. Call Script (NEW)
        function NodeScript() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { scriptName: "" };
            var that = this;
            this.addWidget("text", "Script", "", function (v) { that.properties.scriptName = v; });
            this.title = "Call Script";
            this.bgcolor = "#E91E63";
        }
        NodeScript.title = "Call Script";
        NodeScript.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.scriptName;
            }
        };
        LiteGraph.registerNodeType("bot/script", NodeScript);

        // 6.5 Loop Break (NEW)
        function NodeLoopBreak() {
            this.addInput("Exec", "ACTION");
            this.title = "Break Loop";
            this.bgcolor = "#b71c1c";
        }
        NodeLoopBreak.title = "Break Loop";
        LiteGraph.registerNodeType("bot/loop_break", NodeLoopBreak);

        // 7. Find Image (Updated for Menu & Data Flow)
        function NodeFindImage() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Found", "ACTION");
            this.addOutput("Not Found", "ACTION");
            this.addOutput("X", "number");
            this.addOutput("Y", "number");
            this.properties = { template: "", algorithm: "auto" };
            this.title = "Find Image";
            this.bgcolor = "#1565c0";
            var that = this;

            // Button acts as both trigger and display (Index 0)
            this.widget_btn = this.addWidget("button", "Select Image...", null, function (v, canvas, node, pos, event) {
                fetchImageMenu(event, function (path) {
                    that.properties.template = path;
                    that.widget_btn.name = path; // Update button label
                    that.setDirtyCanvas(true, true);
                });
            });

            // Algorithm Combo (Index 1)
            this.addWidget("combo", "Algo", "auto", function (v) {
                that.properties.algorithm = v;
            }, { values: ["auto", "sift", "template"] });

            this.size = this.computeSize();
        }
        NodeFindImage.title = "Find Image";

        // Render description logic
        NodeFindImage.prototype.onDrawForeground = function (ctx) {
            if (this.flags.collapsed) return;

            ctx.fillStyle = "#ccc";
            ctx.font = "10px Arial";
            var algo = this.properties.algorithm;
            var text = "";
            if (algo === 'sift') text = "â„¹ï¸ SIFT: Robust (Scale/Rot)";
            else if (algo === 'template') text = "â„¹ï¸ Template: Exact Match (Fast)";
            else text = "â„¹ï¸ Auto: SIFT first, then Template";

            ctx.fillText(text, 5, this.size[1] + 15); // Draw below the node
        };

        // Restore label on load
        NodeFindImage.prototype.onConfigure = function () {
            if (this.properties.template && this.widgets && this.widgets[0]) {
                this.widgets[0].name = this.properties.template;
            }
            if (this.properties.algorithm && this.widgets && this.widgets[1]) {
                this.widgets[1].value = this.properties.algorithm;
            }
            this.size = this.computeSize();
        };
        LiteGraph.registerNodeType("bot/find_image", NodeFindImage);

        // --- IMAGE MENU LOGIC ---
        var imageTreeCache = null;

        function fetchImageMenu(event, callback) {
            // Load if not loaded
            fetch('/api/images')
                .then(r => r.json())
                .then(data => {
                    imageTreeCache = data.images;
                    const menuOptions = buildLiteGraphMenu(imageTreeCache, callback);
                    new LiteGraph.ContextMenu(menuOptions, { event: event });
                })
                .catch(e => showToast("Error loading images: " + e, 'error'));
        }

        function buildLiteGraphMenu(tree, callback) {
            // Convert tree to ContextMenu format:
            // [{ content: "Label", callback: ... }, { content: "Folder", submenu: { options: [...] } }]
            return tree.map(item => {
                if (item.type === 'folder') {
                    return {
                        content: "ğŸ“ " + item.name,
                        submenu: {
                            options: buildLiteGraphMenu(item.children, callback)
                        }
                    };
                } else {
                    return {
                        content: "ğŸ“„ " + item.name,
                        callback: function () {
                            // "images/sub/foo.png"
                            // Backend path was constructed starting with "images/"
                            // Ensure we pass the cleaner relative path if needed, but existing logic uses full relative path.
                            callback(item.path);
                        }
                    };
                }
            });
        }


        // --- HELPER ACTIONS ---

        function addNode(type) {
            try {
                var node = LiteGraph.createNode(type);
                if (node) {
                    // Safe basic position
                    node.pos = [200, 300];

                    // Try to adjust to view center ONLY if safe
                    var container = document.getElementById("editor-container");
                    if (container && graph && canvas && canvas.ds) {
                        try {
                            var scale = canvas.ds.scale || 1;
                            var offX = canvas.ds.offset ? canvas.ds.offset[0] : 0;
                            var offY = canvas.ds.offset ? canvas.ds.offset[1] : 0;

                            var x = -offX + (container.clientWidth / 2) / scale;
                            var y = -offY + (container.clientHeight / 2) / scale;

                            if (!isNaN(x) && !isNaN(y)) {
                                node.pos = [x - 100, y];
                            }
                        } catch (err) {
                            console.warn("Pos calc error", err);
                        }
                    }
                    graph.add(node);
                } else {
                    showToast("Error: Node type not found: " + type, 'error');
                }
            } catch (e) {
                console.error(e);
                showToast("Error adding node: " + e, 'error');
            }
        }

        // --- CAPTURE & PICKER LOGIC ---

        function captureScreen() {
            fetch('/capture', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') {
                        const img = document.getElementById('screenPreview');
                        img.src = data.url;
                        img.onload = () => { img.style.display = 'block'; document.getElementById('loadingText').style.display = 'none'; };
                    } else {
                        showToast("Capture failed: " + data.message, 'error');
                    }
                })
                .catch(err => showToast("Error: " + err, 'error'));
        }

        function getScaledCoords(event, img) {
            const rect = img.getBoundingClientRect();
            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;
            return {
                x: Math.round(event.offsetX * scaleX),
                y: Math.round(event.offsetY * scaleY)
            };
        }

        function showCoords(event) {
            if (isCoordsLocked) return;

            const img = document.getElementById('screenPreview');
            const display = document.getElementById('coordDisplay');
            if (img.style.display === 'none') return;

            const coords = getScaledCoords(event, img);
            display.innerText = `X:${coords.x}, Y:${coords.y}`;
            display.style.display = 'block';
            display.style.border = 'none';
        }

        function pickCoords(event) {
            const img = document.getElementById('screenPreview');
            const coords = getScaledCoords(event, img);

            // Check selected node
            const selectedArgs = Object.values(canvas.selected_nodes || {});

            // Mode 1: Update Node if selected
            if (selectedArgs.length === 1) {
                const node = selectedArgs[0];
                updateNodeValues(node, coords.x, coords.y);
                return;
            }

            // Mode 2: Toggle Lock if no node selected
            isCoordsLocked = !isCoordsLocked;
            const display = document.getElementById('coordDisplay');

            if (isCoordsLocked) {
                display.innerText = `LOCKED: X:${coords.x}, Y:${coords.y}`;
                display.style.border = '2px solid red';
            } else {
                display.style.border = 'none';
                showCoords(event);
            }
        }

        // Helper to update node props
        function updateNodeValues(node, x, y) {
            if (node.type === "bot/click") {
                node.properties.x = x;
                node.properties.y = y;
                node.widgets[0].value = x;
                node.widgets[1].value = y;
                showToast(`Updated Click to (${x}, ${y})`);
            } else if (node.type === "bot/swipe") {
                // Still need confirm for swipe start/end decision
                if (confirm("Set as Start point (OK) or End point (Cancel)?")) {
                    node.properties.x1 = x;
                    node.properties.y1 = y;
                    node.widgets[0].value = x;
                    node.widgets[1].value = y;
                    showToast(`Updated Swipe Start to (${x}, ${y})`);
                } else {
                    node.properties.x2 = x;
                    node.properties.y2 = y;
                    node.widgets[2].value = x;
                    node.widgets[3].value = y;
                    showToast(`Updated Swipe End to (${x}, ${y})`);
                }
            } else {
                showToast("Node not supported for coords: " + node.type, 'error');
            }
            node.setDirtyCanvas(true, true);
        }

        // --- SYSTEM ACTIONS ---
        function testConnection() {
            fetch('/test_connection', { method: 'POST' })
                .then(res => res.json())
                .then(d => showToast(d.message))
                .catch(e => showToast("Error: " + e, 'error'));
        }

        function shutdownServer() {
            if (confirm("Are you sure you want to stop the server? This will close the application.")) {
                fetch('/shutdown', { method: 'POST' })
                    .then(r => {
                        showToast("Server shutdown. Closing...", 'error');
                        setTimeout(() => window.close(), 1000);
                    })
                    .catch(e => showToast("Error: " + e, 'error'));
            }
        }


        // --- KEYBOARD SHORTCUTS ---
        // --- KEYBOARD SHORTCUTS ---
        window.addEventListener("keydown", function (e) {
            // Delete / Backspace to remove nodes
            if (e.key === "Delete" || e.key === "Backspace") {
                // Ignore if currently focused on an Input-like element
                const target = e.target;
                if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SELECT") {
                    return;
                }

                // Check selection
                // Ensure we have a canvas instance
                if (canvas && canvas.selected_nodes && Object.keys(canvas.selected_nodes).length > 0) {
                    const selected = Object.values(canvas.selected_nodes);
                    if (selected.length > 0) {
                        e.preventDefault(); // Stop Browser Back navigation or other defaults
                        e.stopPropagation(); // Stop matching other listeners

                        selected.forEach(node => {
                            graph.remove(node);
                        });

                        // Force redraw
                        graph.setDirtyCanvas(true, true);
                        showToast("Deleted " + selected.length + " nodes");
                    }
                }
            }
        }, true); // Use Capture phase to ensure we get the event first

        // --- SERIALIZATION & RUN ---

        function serializeGraphToCommands() {
            const nodes = graph._nodes;
            const commands = [];

            // Need a start node
            const startNode = nodes.find(n => n.type === "bot/start");
            if (!startNode) {
                showToast("Error: Missing Start Node!", 'error');
                return null;
            }

            const getNode = (id) => nodes.find(n => n.id === id);

            nodes.forEach(node => {
                let cmd = {
                    id: node.id,
                    type: node.type.replace("bot/", ""),
                    properties: node.properties
                };

                // Map connections
                if (node.outputs) {
                    node.outputs.forEach((output, index) => {
                        if (output.links && output.links.length > 0) {
                            const linkId = output.links[0];
                            const link = graph.links[linkId];
                            if (link) {
                                const targetNode = getNode(link.target_id);
                                if (targetNode) {
                                    // Mapping logic based on node type
                                    if (node.type === "bot/loop") {
                                        if (output.name === "Body") cmd.next_body = targetNode.id;
                                        if (output.name === "Exit") cmd.next_exit = targetNode.id;
                                    }
                                    else if (node.type === "bot/find_image") {
                                        if (output.name === "Found") cmd.next_found = targetNode.id;
                                        if (output.name === "Not Found") cmd.next_not_found = targetNode.id;
                                    }
                                    else {
                                        // Default linear
                                        cmd.next = targetNode.id;
                                    }
                                }
                            }
                        }
                    });
                }

                // Map Inputs (Data Flow) - NEW
                cmd.input_links = {};
                if (node.inputs) {
                    node.inputs.forEach((input, idx) => {
                        if (input.link) {
                            var linkInfo = graph.links[input.link];
                            if (linkInfo) {
                                cmd.input_links[input.name] = {
                                    id: linkInfo.origin_id,
                                    slot: linkInfo.origin_slot
                                };
                            }
                        }
                    });
                }

                commands.push(cmd);
            });
            return commands;
        }

        function runGraph() {
            const actions = serializeGraphToCommands();
            if (!actions) return;
            fetch('/run', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ actions: actions, mode: 'graph' })
            }).then(r => r.json()).then(d => {
                if (d.status === 'success') {
                    showToast("Script started!");
                }
            });
        }

        function stopScript() {
            fetch('/stop', { method: 'POST' }).then(() => showToast("Stop command sent."));
        }

        function clearGraph() {
            if (confirm("Are you sure you want to clear the entire workspace?")) {
                graph.clear();
                initDefault();
                showToast("Workspace cleared.");
            }
        }

        // --- SCRIPT SAVE / LOAD / DELETE ---

        function loadScriptsList() {
            fetch('/api/scripts').then(r => r.json()).then(d => {
                const sel = document.getElementById('savedScripts');
                sel.innerHTML = '<option value="">è¼‰å…¥è…³æœ¬...</option>';
                d.scripts.forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s;
                    opt.text = s;
                    sel.add(opt);
                });
            });
        }
        loadScriptsList();

        function loadGraph(name) {
            if (!name) return;
            document.getElementById('scriptName').value = name;
            fetch('/api/scripts/' + name).then(r => r.json()).then(d => {
                try {
                    if (typeof d.content === 'string') {
                        graph.configure(JSON.parse(d.content));
                        showToast(`Loaded: ${name}`);
                    } else {
                        // legacy
                        graph.clear();
                        showToast("Legacy script format cleared.");
                    }
                } catch (e) {
                    graph.clear();
                }
            });
        }

        function saveGraph() {
            const name = document.getElementById('scriptName').value;
            if (!name) return showToast("Please enter a name", 'error');
            const data = JSON.stringify(graph.serialize());
            fetch('/api/scripts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name, content: data, type: 'graph' })
            }).then(r => r.json()).then(d => {
                showToast(d.message);
                loadScriptsList(); // Refresh list
            });
        }

        function deleteScript() {
            const name = document.getElementById('scriptName').value;
            // Also check dropdown if input is empty?
            var target = name || document.getElementById('savedScripts').value;

            if (!target) return showToast("Select script to delete", 'error');

            if (confirm("Confirm delete script: " + target + "?")) {
                fetch('/api/scripts/' + target, { method: 'DELETE' })
                    .then(r => r.json())
                    .then(d => {
                        showToast(d.message);
                        if (d.status === 'success') {
                            document.getElementById('scriptName').value = '';
                            graph.clear();
                            initDefault();
                            loadScriptsList();
                        }
                    })
                    .catch(e => showToast("Error: " + e, 'error'));
            }
        }

        // Logs Polling
        setInterval(() => {
            fetch('/logs')
                .then(res => res.json())
                .then(data => {
                    const el = document.getElementById('logConsole');
                    if (data.logs) {
                        el.innerHTML = data.logs.map(l =>
                            (typeof l === 'object' ? `[${l.timestamp.split('T')[1].split('.')[0]}] ${l.message}` : l)
                        ).join('<br>');
                        el.scrollTop = el.scrollHeight;
                    }
                });
        }, 1000);

        // Init Default Graph
        function initDefault() {
            var node_start = LiteGraph.createNode("bot/start");
            node_start.pos = [100, 250];
            graph.add(node_start);
        }
        // Only init if empty and no legacy load
        if (graph._nodes.length === 0) {
            initDefault();
        }
        graph.start();

    </script>
</body>

</html>