<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlueStacks Visual Scripting</title>
    <!-- LiteGraph.js (Local) -->
    <link rel="stylesheet" type="text/css" href="/static/css/litegraph.css">
    <script type="text/javascript" src="/static/js/litegraph.js"></script>
    <style>
        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #ddd;
            font-family: 'Segoe UI', sans-serif;
        }

        #main-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            height: 40px;
            background: #222;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
            z-index: 10;
        }

        #workspace {
            display: flex;
            /* Keep flex for editor-container filling */
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            /* Anchor for absolute sidebars */
        }

        /* Sidebar (Left) - Sliding */
        #sidebar {
            width: 200px;
            background: rgba(43, 43, 43, 0.95);
            /* Semi-transparent */
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 10px 25px 10px 10px;
            box-sizing: border-box;
            overflow-y: auto;
            /* Absolute Positioning */
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            z-index: 100;
            /* Sliding Logic */
            transform: translateX(-185px);
            /* Hide most of it */
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
        }

        #sidebar:hover {
            transform: translateX(0);
            /* Slide out */
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.6);
        }

        /* Visual hint strip for Sidebar */
        #sidebar::after {
            content: "â–¶";
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 10px;
            pointer-events: none;
        }

        #sidebar:hover::after {
            display: none;
        }

        #sidebar h3 {
            margin-top: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .node-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #eee;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }

        .node-btn:hover {
            background: #505050;
            transform: translateX(2px);
            border-color: #777;
        }

        /* Colored strips for buttons */
        .btn-start {
            border-left: 3px solid #4CAF50;
        }

        .btn-click {
            border-left: 3px solid #2196F3;
        }

        .btn-swipe {
            border-left: 3px solid #03A9F4;
        }

        .btn-wait {
            border-left: 3px solid #FFC107;
        }

        .btn-loop {
            border-left: 3px solid #673AB7;
        }

        .btn-break {
            border-left: 3px solid #D32F2F;
        }

        .btn-find {
            border-left: 3px solid #1565C0;
        }

        .btn-script {
            border-left: 3px solid #E91E63;
        }

        /* Canvas Container */
        #editor-container {
            width: 100%;
            height: 100%;
            background: #111;
            /* No margin/padding needed */
        }

        canvas#mycanvas {
            width: 100%;
            height: 100%;
            outline: none;
            cursor: crosshair;
        }

        /* Monitor Panel (Right) - Sliding */
        #monitor-panel {
            width: 350px;
            background: rgba(43, 43, 43, 0.95);
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 10px 10px 10px 25px;
            box-sizing: border-box;
            overflow-y: auto;
            /* Absolute Positioning */
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            z-index: 100;
            /* Sliding Logic */
            transform: translateX(335px);
            /* Hide most of it */
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
        }

        #monitor-panel:hover {
            transform: translateX(0);
            /* Slide out */
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.6);
        }

        /* Pinned State (Force Open) */
        #sidebar.pinned,
        #monitor-panel.pinned {
            transform: translateX(0) !important;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        /* Visual hint strip */
        #monitor-panel::after {
            content: "â—€";
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 10px;
            pointer-events: none;
        }

        #monitor-panel:hover::after {
            display: none;
        }

        .monitor-frame {
            background: #000;
            border: 1px solid #555;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
        }

        #screenPreview {
            max-width: 100%;
            max-height: 400px;
            display: none;
            cursor: crosshair;
        }

        /* Toolbar Buttons */
        .tool-btn {
            background: #444;
            color: #ddd;
            border: 1px solid #555;
            padding: 5px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        .tool-btn:hover {
            background: #555;
        }

        .tool-btn.primary {
            background: #2196F3;
            border-color: #1976D2;
            color: white;
        }

        .tool-btn.danger {
            background: #f44336;
            border-color: #d32f2f;
            color: white;
        }

        .tool-btn.block {
            width: 100%;
            margin-bottom: 5px;
        }

        input,
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        /* Log Console (Bottom of Monitor) */
        #logConsole {
            background: #000;
            color: #0f0;
            font-family: monospace;
            padding: 5px;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #444;
            margin-top: auto;
            /* Push to bottom */
            font-size: 12px;
            border-radius: 4px;
        }

        #coordDisplay {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            font-size: 0.8em;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 999;
        }

        /* Toast Notification */
        #toast-notification {
            position: fixed;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: top 0.3s ease-in-out;
            z-index: 2000;
            font-size: 14px;
            border: 1px solid #2196F3;
            pointer-events: none;
        }

        #toast-notification.show {
            top: 20px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background: #2b2b2b;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            color: #ddd;
        }

        .modal-header {
            font-size: 18px;
            margin-bottom: 15px;
            font-weight: bold;
            color: #7289da;
        }

        .modal-body input {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            background: #1a1a1a;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }

        .modal-footer {
            text-align: right;
        }

        .modal-footer button {
            padding: 5px 15px;
            margin-left: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
        }

        .btn-cancel {
            background: #555;
            color: white;
        }

        .btn-save {
            background: #7289da;
            color: white;
        }

        .header-btn i {
            margin-right: 5px;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .header-right button {
            padding: 8px 12px;
            background-color: #34495e;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .header-right button:hover {
            background-color: #2c3e50;
        }
    </style>
</head>

<body>
    <!-- Toast -->
    <div id="toast-notification">Notification</div>

    <!-- Main Header moved inside main-layout -->
    <div id="discord-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px; width: 90%;">
            <div class="modal-header">Discord Bot Settings</div>

            <div style="display: flex; gap: 20px; padding: 10px;">
                <!-- Left Column: Bot Config -->
                <div style="flex: 1; border-right: 1px solid #444; padding-right: 20px;">
                    <h3>ğŸ¤– Bot Config</h3>
                    <label style="display:block; margin-bottom:5px;">Bot Token:</label>
                    <input type="password" id="discord-token" placeholder="Enter your Discord Bot Token">

                    <label style="display:block; margin-bottom:5px; margin-top:10px;">User ID:</label>
                    <input type="text" id="discord-user-id" placeholder="Enter your Discord User ID">

                    <div
                        style="font-size: 12px; color: #888; background: #222; padding: 10px; border-radius: 4px; margin-top: 15px;">
                        <strong>å¦‚ä½•ç²å– User ID:</strong><br>
                        1. é–‹å•Ÿ Discord é–‹ç™¼è€…æ¨¡å¼ã€‚<br>
                        2. å³éµé»æ“Šä½ çš„é ­åƒ -> è¤‡è£½ä½¿ç”¨è€… IDã€‚<br>
                        <br>
                        <strong>å¦‚ä½•ç²å– Bot Token:</strong><br>
                        1. å‰å¾€ Discord Developer Portalã€‚<br>
                        2. å»ºç«‹ Application -> Botã€‚<br>
                        3. è¤‡è£½ Tokenã€‚<br>
                        4. OAuth2 -> URL Generator -> å‹¾é¸ <code>bot</code>, <code>Send Messages</code>ã€‚<br>
                        5. é‚€è«‹ Bot åŠ å…¥ä¼ºæœå™¨ã€‚<br>
                    </div>
                </div>

                <!-- Right Column: Command Declaration -->
                <div style="flex: 1;">
                    <h3>ğŸ“¢ Declare Commands</h3>
                    <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;">
                        åœ¨æ­¤å®šç¾©æ‰€æœ‰ Slash æŒ‡ä»¤ã€‚æ©Ÿå™¨äººå•Ÿå‹•æ™‚æœƒè¨»å†Šé€™äº›æŒ‡ä»¤ã€‚<br>
                        Define all commands here. Bot registers them on startup.
                    </p>

                    <div id="command-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 10px;">
                        <!-- Commands will be added here dynamically -->
                    </div>

                    <button class="run-btn" onclick="addCommandItem()"
                        style="background-color: #3498db; width: 100%; margin-bottom: 5px;">+ Add Command</button>
                    <p style="font-size: 10px; color: #666;">
                        * é€™äº›æŒ‡ä»¤æœƒæ°¸ä¹…å­˜åœ¨ Discord ç›´åˆ°ä½ åˆªé™¤å®ƒå€‘ã€‚<br>
                        * These commands persist in Discord until removed.
                    </p>
                </div>
            </div>

            <div class="modal-footer">
                <button class="run-btn" style="background:#7f8c8d; margin-right: 10px;"
                    onclick="closeDiscordSettings()">Cancel</button>
                <button class="run-btn" style="background:#2ecc71;" onclick="saveDiscordSettings()">Save & Restart
                    Bot</button>
            </div>
        </div>
    </div>
    </div>

    <div id="main-layout">
        <!-- Main Header -->
        <div
            style="background: #2c3e50; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin:0;">BrownFarm Automation</h2>
            <div class="header-right">
                <button onclick="window.location.href='/api/logs/export'">ğŸ“„ Export Logs</button>
                <button onclick="openDiscordSettings()">âš™ï¸ Discord Settings</button>
            </div>
        </div>
        <!-- Top Toolbar -->
        <div id="toolbar">
            <span style="font-weight:bold; margin-right:20px; font-size:16px;">BlueStacks Editor</span>
            <button class="tool-btn primary" onclick="runGraph()">â–¶ åŸ·è¡Œ (Run)</button>
            <button class="tool-btn danger" onclick="stopScript()">â¹ åœæ­¢ (Stop)</button>
            <button class="tool-btn" onclick="clearGraph()">ğŸ§¹ æ¸…ç©º (Clear)</button>
            <div style="flex-grow:1"></div>
            <input type="text" id="scriptName" placeholder="Script Name" style="width: 150px;">
            <button class="tool-btn" onclick="saveGraph()">å„²å­˜ (Save)</button>
            <select id="savedScripts" onchange="loadGraph(this.value)">
                <option value="">è¼‰å…¥è…³æœ¬...</option>
            </select>
            <button class="tool-btn danger" onclick="deleteScript()" style="padding: 5px 10px;">ğŸ—‘ï¸</button>
        </div>

        <!-- Main Workspace -->
        <div id="workspace">
            <!-- Sidebar (Left) -->
            <div id="sidebar">
                <h3>æµç¨‹æ§åˆ¶</h3>
                <button class="node-btn btn-start" onclick="addNode('bot/start')">ğŸ é–‹å§‹ (Start)</button>
                <button class="node-btn btn-script" onclick="addNode('bot/script')">ğŸ“œ å‘¼å«è…³æœ¬ (Call Script)</button>
                <button class="node-btn btn-wait" onclick="addNode('bot/wait')">â³ ç­‰å¾… (Wait)</button>
                <button class="node-btn btn-loop" onclick="addNode('bot/loop')">ğŸ”„ è¿´åœˆ (Loop)</button>
                <button class="node-btn btn-break" onclick="addNode('bot/loop_break')">ğŸ›‘ è·³å‡ºè¿´åœˆ (Break)</button>

                <h3>åŸºæœ¬å‹•ä½œ</h3>
                <button class="node-btn btn-click" onclick="addNode('bot/click')">ğŸ–±ï¸ é»æ“Š (Click)</button>
                <button class="node-btn btn-swipe" onclick="addNode('bot/swipe')">ğŸ‘† æ»‘å‹• (Swipe)</button>

                <h3>è¦–è¦ºè¾¨è­˜</h3>
                <button class="node-btn btn-find" onclick="addNode('bot/find_image')">ğŸ–¼ï¸ æ‰¾åœ– (Find Image)</button>

                <h3>Discord Bot</h3>
                <button class="node-btn" style="border-left: 3px solid #7289da;" onclick="openDiscordSettings()">âš™ï¸ è¨­å®š
                    (Settings)</button>
                <button class="node-btn" style="border-left: 3px solid #7289da;"
                    onclick="addNode('bot/discord_send')">ğŸ“¤ ç™¼é€è¨Šæ¯ (Send Msg)</button>
                <button class="node-btn" style="border-left: 3px solid #faa61a;"
                    onclick="addNode('bot/discord_slash')">âš¡ Slash æŒ‡ä»¤ (Slash Event)</button>
                <button class="node-btn" style="border-left: 3px solid #e67e22;"
                    onclick="addNode('bot/discord_wait')">ğŸ›‘ ç­‰å¾…æŒ‡ä»¤ (Wait /Cmd)</button>
            </div>

            <!-- Canvas (Center) -->
            <div id="editor-container">
                <canvas id="mycanvas"></canvas>
            </div>

            <!-- Monitor (Right) -->
            <div id="monitor-panel">
                <h3>ç›£æ§èˆ‡æ“ä½œ</h3>

                <div class="monitor-frame">
                    <img id="screenPreview" src="" onmousemove="showCoords(event)" onclick="pickCoords(event)">
                    <div id="coordDisplay">X:0, Y:0</div>
                    <div id="loadingText" style="color:#666">No Image</div>
                </div>

                <button class="tool-btn block" onclick="captureScreen()">ğŸ“· æˆªåœ– (Refresh Screen)</button>
                <div style="font-size:0.8em; color:#888; margin-bottom:10px; text-align:center;">
                    é»æ“Šç•«é¢: é–å®šåº§æ¨™ / å¡«å…¥é¸å–çš„ç¯€é»
                </div>

                <hr style="width:100%; border:0; border-top:1px solid #444;">

                <button class="tool-btn block" onclick="testConnection()">ğŸ”Œ æ¸¬è©¦é€£ç·š (Test)</button>
                <button class="tool-btn block danger" onclick="shutdownServer()">âš ï¸ é—œé–‰ä¼ºæœå™¨ (Shutdown)</button>

                <h3>åŸ·è¡Œæ—¥èªŒ</h3>
                <div id="logConsole">Waiting for logs...</div>
            </div>
        </div>
    </div>

    <script>
        // Init LiteGraph
        var graph = new LGraph();
        var canvas = new LGraphCanvas("#mycanvas", graph);

        function resize() {
            var container = document.getElementById("editor-container");
            if (container) {
                canvas.resize(container.clientWidth, container.clientHeight);
                graph.setDirtyCanvas(true, true);
            }
        }
        window.addEventListener("resize", resize);
        window.addEventListener("resize", resize);
        setTimeout(resize, 100);

        // Sidebar Pin Logic: Start Open, Collapse on Mouse Leave
        window.addEventListener('load', () => {
            const s = document.getElementById('sidebar');
            const m = document.getElementById('monitor-panel');

            if (s && m) {
                s.classList.add('pinned');
                m.classList.add('pinned');

                // Remove pinned state on first mouse exit
                s.addEventListener('mouseleave', () => { s.classList.remove('pinned'); }, { once: true });
                m.addEventListener('mouseleave', () => { m.classList.remove('pinned'); }, { once: true });
            }
        });

        // --- GLOBAL STATE ---
        var isCoordsLocked = false;
        var toastTimeout = null;

        // --- TOAST NOTIFICATION ---
        function showToast(message, type = 'info') {
            const toast = document.getElementById("toast-notification");
            toast.innerText = message;
            toast.classList.add("show");

            if (type === 'error') {
                toast.style.borderColor = '#ff4444';
            } else {
                toast.style.borderColor = '#2196F3';
            }

            if (toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toast.classList.remove("show");
            }, 2000);
        }

        // --- CUSTOM NODES ---

        // 1. Start
        function NodeStart() {
            this.addOutput("Exec", "ACTION");
            this.title = "â–¶ Start";
            this.bgcolor = "#2e7d32";
        }
        NodeStart.title = "Start";
        LiteGraph.registerNodeType("bot/start", NodeStart);

        // 2. Click
        function NodeClick() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.addInput("X", "number");
            this.addInput("Y", "number");
            this.properties = { x: 500, y: 500 };
            this.addWidget("number", "X", 500, function (v) { this.properties.x = v; }, { min: 0, max: 9999, precision: 0 });
            this.addWidget("number", "Y", 500, function (v) { this.properties.y = v; }, { min: 0, max: 9999, precision: 0 });
            this.title = "Click";
        }
        NodeClick.title = "Click";
        NodeClick.prototype.onExecute = function () { this.triggerSlot(0); }

        NodeClick.prototype.updateWidgetState = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].disabled = this.isInputConnected(1);
                if (this.widgets[1]) this.widgets[1].disabled = this.isInputConnected(2);
            }
        };

        NodeClick.prototype.onConnectionsChange = function (type, slot, connected, link_info, input_info) {
            if (type === LiteGraph.INPUT) {
                this.updateWidgetState();
            }
        };

        NodeClick.prototype.onConfigure = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].value = this.properties.x;
                if (this.widgets[1]) this.widgets[1].value = this.properties.y;
            }
            this.updateWidgetState();
        };
        LiteGraph.registerNodeType("bot/click", NodeClick);

        // 3. Swipe
        function NodeSwipe() {
            this.addInput("Exec", "ACTION");
            this.addInput("X1", "number");
            this.addInput("Y1", "number");
            this.addInput("X2", "number");
            this.addInput("Y2", "number");
            this.addOutput("Exec", "ACTION");
            this.properties = { x1: 500, y1: 800, x2: 500, y2: 200, duration: 500 };
            this.addWidget("number", "X1", 500, function (v) { this.properties.x1 = v; });
            this.addWidget("number", "Y1", 800, function (v) { this.properties.y1 = v; });
            this.addWidget("number", "X2", 500, function (v) { this.properties.x2 = v; });
            this.addWidget("number", "Y2", 200, function (v) { this.properties.y2 = v; });
            this.addWidget("number", "Time(ms)", 500, function (v) { this.properties.duration = v; });
            this.title = "Swipe";
            this.bgcolor = "#2196F3";
        }
        NodeSwipe.title = "Swipe";

        NodeSwipe.prototype.updateWidgetState = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].disabled = this.isInputConnected(1);
                if (this.widgets[1]) this.widgets[1].disabled = this.isInputConnected(2);
                if (this.widgets[2]) this.widgets[2].disabled = this.isInputConnected(3);
                if (this.widgets[3]) this.widgets[3].disabled = this.isInputConnected(4);
            }
        };

        NodeSwipe.prototype.onConnectionsChange = function (type, slot, connected, link_info, input_info) {
            if (type === LiteGraph.INPUT) {
                this.updateWidgetState();
            }
        };

        NodeSwipe.prototype.onConfigure = function () {
            if (this.widgets) {
                if (this.widgets[0]) this.widgets[0].value = this.properties.x1;
                if (this.widgets[1]) this.widgets[1].value = this.properties.y1;
                if (this.widgets[2]) this.widgets[2].value = this.properties.x2;
                if (this.widgets[3]) this.widgets[3].value = this.properties.y2;
                if (this.widgets[4]) this.widgets[4].value = this.properties.duration;
            }
            this.updateWidgetState();
        };
        LiteGraph.registerNodeType("bot/swipe", NodeSwipe);

        // 4. Wait
        function NodeWait() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { seconds: 1.0 };
            this.addWidget("number", "Seconds", 1.0, function (v) { this.properties.seconds = v; }, { step: 0.1, min: 0 });
            this.title = "Wait";
        }
        NodeWait.title = "Wait";
        NodeWait.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.seconds;
            }
        };
        LiteGraph.registerNodeType("bot/wait", NodeWait);

        // 5. Loop (Updated)
        function NodeLoop() {
            var that = this;
            this.addInput("Exec", "ACTION");
            this.addOutput("Body", "ACTION");
            this.addOutput("Exit", "ACTION");
            this.properties = { count: 3 };
            this.addWidget("number", "Count (0=Inf)", 3, function (v) {
                var val = Math.max(0, Math.floor(v));
                that.properties.count = val;
                // Force UI to show integer
                if (that.widgets && that.widgets[0]) that.widgets[0].value = val;
            }, { min: 0, step: 10, precision: 0 });
            this.title = "Loop";
            this.bgcolor = "#673AB7";
        }
        NodeLoop.title = "Loop";
        NodeLoop.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.count;
            }
        };
        LiteGraph.registerNodeType("bot/loop", NodeLoop);

        // 6. Call Script (NEW)
        function NodeScript() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { scriptName: "" };
            var that = this;
            this.addWidget("text", "Script", "", function (v) { that.properties.scriptName = v; });
            this.title = "Call Script";
            this.bgcolor = "#E91E63";
        }
        NodeScript.title = "Call Script";
        NodeScript.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) {
                this.widgets[0].value = this.properties.scriptName;
            }
        };
        LiteGraph.registerNodeType("bot/script", NodeScript);

        // 6.5 Loop Break (NEW)
        function NodeLoopBreak() {
            this.addInput("Exec", "ACTION");
            this.title = "Break Loop";
            this.bgcolor = "#b71c1c";
        }
        NodeLoopBreak.title = "Break Loop";
        LiteGraph.registerNodeType("bot/loop_break", NodeLoopBreak);

        // 7. Find Image (Updated for Menu & Data Flow)
        function NodeFindImage() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Found", "ACTION");
            this.addOutput("Not Found", "ACTION");
            this.addOutput("X", "number");
            this.addOutput("Y", "number");
            this.properties = { template: "", algorithm: "auto" };
            this.title = "Find Image";
            this.bgcolor = "#1565c0";
            var that = this;

            // Button acts as both trigger and display (Index 0)
            this.widget_btn = this.addWidget("button", "Select Image...", null, function (v, canvas, node, pos, event) {
                fetchImageMenu(event, function (path) {
                    that.properties.template = path;
                    that.widget_btn.name = path; // Update button label
                    that.setDirtyCanvas(true, true);
                });
            });

            // Algorithm Combo (Index 1)
            this.addWidget("combo", "Algo", "auto", function (v) {
                that.properties.algorithm = v;
            }, { values: ["auto", "sift", "template"] });

            this.size = this.computeSize();
        }
        NodeFindImage.title = "Find Image";

        // Render description logic
        NodeFindImage.prototype.onDrawForeground = function (ctx) {
            if (this.flags.collapsed) return;

            ctx.fillStyle = "#ccc";
            ctx.font = "10px Arial";
            var algo = this.properties.algorithm;
            var text = "";
            if (algo === 'sift') text = "â„¹ï¸ SIFT: Robust (Scale/Rot)";
            else if (algo === 'template') text = "â„¹ï¸ Template: Exact Match (Fast)";
            else text = "â„¹ï¸ Auto: SIFT first, then Template";

            ctx.fillText(text, 5, this.size[1] + 15); // Draw below the node
        };

        // Restore label on load
        NodeFindImage.prototype.onConfigure = function () {
            if (this.properties.template && this.widgets && this.widgets[0]) {
                this.widgets[0].name = this.properties.template;
            }
            if (this.properties.algorithm && this.widgets && this.widgets[1]) {
                this.widgets[1].value = this.properties.algorithm;
            }
            this.size = this.computeSize();
        };
        LiteGraph.registerNodeType("bot/find_image", NodeFindImage);

        // 8. Discord Send Message
        function NodeDiscordSend() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { message: "Hello!" };
            var that = this;
            this.addWidget("text", "Message", "Hello!", function (v) { that.properties.message = v; });
            this.title = "Send Discord Msg";
            this.bgcolor = "#7289da";
        }
        NodeDiscordSend.title = "Send Discord Msg";
        NodeDiscordSend.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) this.widgets[0].value = this.properties.message;
        };
        LiteGraph.registerNodeType("bot/discord_send", NodeDiscordSend);

        // Global cache for declared commands
        window.declaredCommands = [];

        function updateDeclaredCommandsCache() {
            fetch('/api/settings')
                .then(r => r.json())
                .then(data => {
                    if (data.commands && Array.isArray(data.commands)) {
                        window.declaredCommands = data.commands;
                    } else {
                        window.declaredCommands = [{ name: 'run', desc: 'Start script' }, { name: 'stop', desc: 'Stop script' }];
                    }
                })
                .catch(e => console.error("Failed to fetch commands", e));
        }
        // Initial fetch
        updateDeclaredCommandsCache();

        // 9. Discord Slash Command (Trigger)
        function NodeDiscordSlash() {
            this.addOutput("Exec", "ACTION");
            this.properties = { command_name: "Select", description: "" };
            var that = this;

            // Dynamic Combo Widget
            this.addWidget("combo", "Command /", "Select", function (v) {
                that.properties.command_name = v;
                // Auto-update description
                const cmd = window.declaredCommands.find(function (c) { return c.name === v; });
                if (cmd) {
                    that.properties.description = cmd.desc;
                    if (that.widgets[1]) that.widgets[1].value = cmd.desc;
                } else if (v === 'Select') {
                    that.properties.description = "";
                    if (that.widgets[1]) that.widgets[1].value = "";
                }
            }, {
                values: function () {
                    var cmds = window.declaredCommands.map(function (c) { return c.name; });
                    return ["Select"].concat(cmds);
                }
            });

            // Description (Read-ish)
            this.addWidget("text", "Desc", "", function (v) { that.properties.description = v; });

            this.title = "Slash Event";
            this.bgcolor = "#faa61a";
            this.shape = 1;
            this.size = [240, 80];
        }
        NodeDiscordSlash.title = "Slash Event";
        NodeDiscordSlash.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) this.widgets[0].value = this.properties.command_name;
            if (this.widgets && this.widgets[1]) this.widgets[1].value = this.properties.description || "";
            this.size = [240, 80]; // Force resize
        };
        LiteGraph.registerNodeType("bot/discord_slash", NodeDiscordSlash);

        // 10. Discord Wait (Blocking)
        function NodeDiscordWait() {
            this.addInput("Exec", "ACTION");
            this.addOutput("Exec", "ACTION");
            this.properties = { command_name: "Select", description: "" };
            var that = this;

            // Dynamic Combo Widget
            this.addWidget("combo", "Command /", "Select", function (v) {
                that.properties.command_name = v;
                // Auto-update description
                const cmd = window.declaredCommands.find(function (c) { return c.name === v; });
                if (cmd) {
                    that.properties.description = cmd.desc;
                    if (that.widgets[1]) that.widgets[1].value = cmd.desc;
                } else if (v === 'Select') {
                    that.properties.description = "";
                    if (that.widgets[1]) that.widgets[1].value = "";
                }
            }, {
                values: function () {
                    var cmds = window.declaredCommands.map(function (c) { return c.name; });
                    return ["Select"].concat(cmds);
                }
            });

            // Description
            this.addWidget("text", "Desc", "", function (v) { that.properties.description = v; });

            this.title = "Wait for /Cmd";
            this.bgcolor = "#e67e22";
            this.size = [240, 80];
        }
        NodeDiscordWait.title = "Wait for /Cmd";
        NodeDiscordWait.prototype.onConfigure = function () {
            if (this.widgets && this.widgets[0]) this.widgets[0].value = this.properties.command_name;
            if (this.widgets && this.widgets[1]) this.widgets[1].value = this.properties.description || "";
            this.size = [240, 80]; // Force resize
        };
        LiteGraph.registerNodeType("bot/discord_wait", NodeDiscordWait);

        // --- IMAGE MENU LOGIC ---
        var imageTreeCache = null;

        function fetchImageMenu(event, callback) {
            // Load if not loaded
            fetch('/api/images')
                .then(r => r.json())
                .then(data => {
                    imageTreeCache = data.images;
                    const menuOptions = buildLiteGraphMenu(imageTreeCache, callback);
                    new LiteGraph.ContextMenu(menuOptions, { event: event });
                })
                .catch(e => showToast("Error loading images: " + e, 'error'));
        }

        function buildLiteGraphMenu(tree, callback) {
            // Convert tree to ContextMenu format:
            // [{ content: "Label", callback: ... }, { content: "Folder", submenu: { options: [...] } }]
            return tree.map(item => {
                if (item.type === 'folder') {
                    return {
                        content: "ğŸ“ " + item.name,
                        submenu: {
                            options: buildLiteGraphMenu(item.children, callback)
                        }
                    };
                } else {
                    return {
                        content: "ğŸ“„ " + item.name,
                        callback: function () {
                            // "images/sub/foo.png"
                            // Backend path was constructed starting with "images/"
                            // Ensure we pass the cleaner relative path if needed, but existing logic uses full relative path.
                            callback(item.path);
                        }
                    };
                }
            });
        }


        // --- HELPER ACTIONS ---

        function addNode(type) {
            try {
                var node = LiteGraph.createNode(type);
                if (node) {
                    // Safe basic position
                    node.pos = [200, 300];

                    // Try to adjust to view center ONLY if safe
                    var container = document.getElementById("editor-container");
                    if (container && graph && canvas && canvas.ds) {
                        try {
                            var scale = canvas.ds.scale || 1;
                            var offX = canvas.ds.offset ? canvas.ds.offset[0] : 0;
                            var offY = canvas.ds.offset ? canvas.ds.offset[1] : 0;

                            var x = -offX + (container.clientWidth / 2) / scale;
                            var y = -offY + (container.clientHeight / 2) / scale;

                            if (!isNaN(x) && !isNaN(y)) {
                                node.pos = [x - 100, y];
                            }
                        } catch (err) {
                            console.warn("Pos calc error", err);
                        }
                    }
                    graph.add(node);
                } else {
                    showToast("Error: Node type not found: " + type, 'error');
                }
            } catch (e) {
                console.error(e);
                showToast("Error adding node: " + e, 'error');
            }
        }

        // --- CAPTURE & PICKER LOGIC ---

        function captureScreen() {
            fetch('/capture', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') {
                        const img = document.getElementById('screenPreview');
                        img.src = data.url;
                        img.onload = () => { img.style.display = 'block'; document.getElementById('loadingText').style.display = 'none'; };
                    } else {
                        showToast("Capture failed: " + data.message, 'error');
                    }
                })
                .catch(err => showToast("Error: " + err, 'error'));
        }

        function getScaledCoords(event, img) {
            const rect = img.getBoundingClientRect();
            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;
            return {
                x: Math.round(event.offsetX * scaleX),
                y: Math.round(event.offsetY * scaleY)
            };
        }

        function showCoords(event) {
            if (isCoordsLocked) return;

            const img = document.getElementById('screenPreview');
            const display = document.getElementById('coordDisplay');
            if (img.style.display === 'none') return;

            const coords = getScaledCoords(event, img);
            display.innerText = `X:${coords.x}, Y:${coords.y}`;
            display.style.display = 'block';
            display.style.border = 'none';
        }

        function pickCoords(event) {
            const img = document.getElementById('screenPreview');
            const coords = getScaledCoords(event, img);

            // Check selected node
            const selectedArgs = Object.values(canvas.selected_nodes || {});

            // Mode 1: Update Node if selected
            if (selectedArgs.length === 1) {
                const node = selectedArgs[0];
                updateNodeValues(node, coords.x, coords.y);
                return;
            }

            // Mode 2: Toggle Lock if no node selected
            isCoordsLocked = !isCoordsLocked;
            const display = document.getElementById('coordDisplay');

            if (isCoordsLocked) {
                display.innerText = `LOCKED: X:${coords.x}, Y:${coords.y}`;
                display.style.border = '2px solid red';
            } else {
                display.style.border = 'none';
                showCoords(event);
            }
        }

        // Helper to update node props
        function updateNodeValues(node, x, y) {
            if (node.type === "bot/click") {
                node.properties.x = x;
                node.properties.y = y;
                node.widgets[0].value = x;
                node.widgets[1].value = y;
                showToast(`Updated Click to (${x}, ${y})`);
            } else if (node.type === "bot/swipe") {
                // Still need confirm for swipe start/end decision
                if (confirm("Set as Start point (OK) or End point (Cancel)?")) {
                    node.properties.x1 = x;
                    node.properties.y1 = y;
                    node.widgets[0].value = x;
                    node.widgets[1].value = y;
                    showToast(`Updated Swipe Start to (${x}, ${y})`);
                } else {
                    node.properties.x2 = x;
                    node.properties.y2 = y;
                    node.widgets[2].value = x;
                    node.widgets[3].value = y;
                    showToast(`Updated Swipe End to (${x}, ${y})`);
                }
            } else {
                showToast("Node not supported for coords: " + node.type, 'error');
            }
            node.setDirtyCanvas(true, true);
        }

        // --- SYSTEM ACTIONS ---
        function testConnection() {
            fetch('/test_connection', { method: 'POST' })
                .then(res => res.json())
                .then(d => showToast(d.message))
                .catch(e => showToast("Error: " + e, 'error'));
        }

        function shutdownServer() {
            if (confirm("Are you sure you want to stop the server? This will close the application.")) {
                fetch('/shutdown', { method: 'POST' })
                    .then(r => {
                        showToast("Server shutdown. Closing...", 'error');
                        setTimeout(() => window.close(), 1000);
                    })
                    .catch(e => showToast("Error: " + e, 'error'));
            }
        }


        // --- KEYBOARD SHORTCUTS ---
        // --- KEYBOARD SHORTCUTS ---
        window.addEventListener("keydown", function (e) {
            // Delete / Backspace to remove nodes
            if (e.key === "Delete" || e.key === "Backspace") {
                // Ignore if currently focused on an Input-like element
                const target = e.target;
                if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SELECT") {
                    return;
                }

                // Check selection
                // Ensure we have a canvas instance
                if (canvas && canvas.selected_nodes && Object.keys(canvas.selected_nodes).length > 0) {
                    const selected = Object.values(canvas.selected_nodes);
                    if (selected.length > 0) {
                        e.preventDefault(); // Stop Browser Back navigation or other defaults
                        e.stopPropagation(); // Stop matching other listeners

                        selected.forEach(node => {
                            graph.remove(node);
                        });

                        // Force redraw
                        graph.setDirtyCanvas(true, true);
                        showToast("Deleted " + selected.length + " nodes");
                    }
                }
            }
        }, true); // Use Capture phase to ensure we get the event first

        // Global click to blur inputs
        window.addEventListener('mousedown', function (e) {
            // If clicking on canvas or workspace background, blur any focused input
            if (e.target.id === 'editor-container' || e.target.tagName === 'CANVAS') {
                if (document.activeElement && (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "SELECT")) {
                    document.activeElement.blur();
                }
                // Also ensure graph gets focus
                if (graph && graph.list_of_graphcanvas && graph.list_of_graphcanvas.length > 0) {
                    graph.list_of_graphcanvas[0].el.focus();
                } else if (canvas && canvas.el) {
                    canvas.el.focus();
                }
            }
        });

        // --- SERIALIZATION & RUN ---

        function serializeGraphToCommands() {
            const nodes = graph._nodes;
            const commands = [];

            // Need a start node
            const startNode = nodes.find(n => n.type === "bot/start");
            if (!startNode) {
                showToast("Error: Missing Start Node!", 'error');
                return null;
            }

            const getNode = (id) => nodes.find(n => n.id === id);

            nodes.forEach(node => {
                let cmd = {
                    id: node.id,
                    type: node.type.replace("bot/", ""),
                    properties: node.properties
                };

                // Map connections
                if (node.outputs) {
                    node.outputs.forEach((output, index) => {
                        if (output.links && output.links.length > 0) {
                            const linkId = output.links[0];
                            const link = graph.links[linkId];
                            if (link) {
                                const targetNode = getNode(link.target_id);
                                if (targetNode) {
                                    // Mapping logic based on node type
                                    if (node.type === "bot/loop") {
                                        if (output.name === "Body") cmd.next_body = targetNode.id;
                                        if (output.name === "Exit") cmd.next_exit = targetNode.id;
                                    }
                                    else if (node.type === "bot/find_image") {
                                        if (output.name === "Found") cmd.next_found = targetNode.id;
                                        if (output.name === "Not Found") cmd.next_not_found = targetNode.id;
                                    }
                                    else {
                                        // Default linear
                                        cmd.next = targetNode.id;
                                    }
                                }
                            }
                        }
                    });
                }

                // Map Inputs (Data Flow) - NEW
                cmd.input_links = {};
                if (node.inputs) {
                    node.inputs.forEach((input, idx) => {
                        if (input.link) {
                            var linkInfo = graph.links[input.link];
                            if (linkInfo) {
                                cmd.input_links[input.name] = {
                                    id: linkInfo.origin_id,
                                    slot: linkInfo.origin_slot
                                };
                            }
                        }
                    });
                }

                commands.push(cmd);
            });
            return commands;
        }

        function runGraph() {
            const actions = serializeGraphToCommands();
            if (!actions) return;
            fetch('/run', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ actions: actions, mode: 'graph' })
            }).then(r => r.json()).then(d => {
                if (d.status === 'success') {
                    showToast("Script started!");
                }
            });
        }

        function stopScript() {
            fetch('/stop', { method: 'POST' }).then(() => showToast("Stop command sent."));
        }

        function clearGraph() {
            if (confirm("Are you sure you want to clear the entire workspace?")) {
                graph.clear();
                initDefault();
                showToast("Workspace cleared.");
            }
        }

        // --- SCRIPT SAVE / LOAD / DELETE ---

        function loadScriptsList() {
            fetch('/api/scripts').then(r => r.json()).then(d => {
                const sel = document.getElementById('savedScripts');
                sel.innerHTML = '<option value="">è¼‰å…¥è…³æœ¬...</option>';
                d.scripts.forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s;
                    opt.text = s;
                    sel.add(opt);
                });
            });
        }
        loadScriptsList();

        function loadGraph(name) {
            if (!name) return;
            document.getElementById('scriptName').value = name;
            fetch('/api/scripts/' + name).then(r => r.json()).then(d => {
                try {
                    if (typeof d.content === 'string') {
                        graph.configure(JSON.parse(d.content));
                        showToast(`Loaded: ${name}`);
                    } else {
                        // legacy
                        graph.clear();
                        showToast("Legacy script format cleared.");
                    }
                } catch (e) {
                    graph.clear();
                }
                // Ensure canvas has focus so keyboard events work immediately
                if (canvas) {
                    canvas.el.focus();
                    // Or simulate a click? LiteGraph sometimes needs a click to activate context.
                    // But explicitly blurring active element helps.
                    if (document.activeElement) document.activeElement.blur();
                }
            });
        }

        function saveGraph() {
            const name = document.getElementById('scriptName').value;
            if (!name) return showToast("Please enter a name", 'error');
            const data = JSON.stringify(graph.serialize());
            fetch('/api/scripts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name, content: data, type: 'graph' })
            }).then(r => r.json()).then(d => {
                showToast(d.message);
                loadScriptsList(); // Refresh list
            });
        }

        function deleteScript() {
            const name = document.getElementById('scriptName').value;
            // Also check dropdown if input is empty?
            var target = name || document.getElementById('savedScripts').value;

            if (!target) return showToast("Select script to delete", 'error');

            if (confirm("Confirm delete script: " + target + "?")) {
                fetch('/api/scripts/' + target, { method: 'DELETE' })
                    .then(r => r.json())
                    .then(d => {
                        showToast(d.message);
                        if (d.status === 'success') {
                            document.getElementById('scriptName').value = '';
                            graph.clear();
                            initDefault();
                            loadScriptsList();
                        }
                    })
                    .catch(e => showToast("Error: " + e, 'error'));
            }
        }

        // Logs Polling
        setInterval(() => {
            fetch('/logs')
                .then(res => res.json())
                .then(data => {
                    const el = document.getElementById('logConsole');
                    if (data.logs) {
                        el.innerHTML = data.logs.map(l =>
                            (typeof l === 'object' ? `[${l.timestamp.split('T')[1].split('.')[0]}] ${l.message}` : l)
                        ).join('<br>');
                        el.scrollTop = el.scrollHeight;
                    }
                });
        }, 1000);

        // Init Default Graph
        function initDefault() {
            var node_start = LiteGraph.createNode("bot/start");
            node_start.pos = [100, 250];
            graph.add(node_start);
        }
        // Only init if empty and no legacy load
        if (graph._nodes.length === 0) {
            initDefault();
        }
        graph.start();

        // --- COMMAND LIST LOGIC ---
        function addCommandItem(name = "", desc = "") {
            const list = document.getElementById('command-list');
            const div = document.createElement('div');
            div.className = "command-item";
            div.style.cssText = "display: flex; gap: 5px; margin-bottom: 5px;";
            div.innerHTML = `
                <input type="text" class="cmd-name" placeholder="Name (e.g. run)" value="${name}" style="flex: 1; min-width: 80px;">
                <input type="text" class="cmd-desc" placeholder="Details" value="${desc}" style="flex: 2;">
                <button onclick="this.parentElement.remove()" style="background: #e74c3c; border: none; color: white; cursor: pointer;">X</button>
            `;
            list.appendChild(div);
        }

        function getCommandList() {
            const items = document.querySelectorAll('.command-item');
            const commands = [];
            items.forEach(item => {
                const name = item.querySelector('.cmd-name').value.trim();
                const desc = item.querySelector('.cmd-desc').value.trim();
                if (name) commands.push({ name, desc });
            });
            return commands;
        }

        // --- DISCORD SETTINGS ---
        function openDiscordSettings() {
            const modal = document.getElementById('discord-modal');
            const tokenInput = document.getElementById('discord-token');
            const userIdInput = document.getElementById('discord-user-id');
            modal.style.display = 'flex';

            // Load current settings
            fetch('/api/settings')
                .then(r => r.json())
                .then(data => {
                    if (data.discord_token) tokenInput.value = data.discord_token;
                    if (data.user_id) userIdInput.value = data.user_id;

                    // Load commands
                    const list = document.getElementById('command-list');
                    list.innerHTML = "";
                    if (data.commands && Array.isArray(data.commands)) {
                        data.commands.forEach(cmd => addCommandItem(cmd.name, cmd.desc));
                    } else {
                        // Default suggestion if empty
                        // addCommandItem('run', 'Start script');
                    }
                })
                .catch(e => console.error(e));
        }

        function closeDiscordSettings() {
            document.getElementById('discord-modal').style.display = 'none';
        }

        function saveDiscordSettings() {
            const token = document.getElementById('discord-token').value;
            const userId = document.getElementById('discord-user-id').value;
            const commands = getCommandList();

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    discord_token: token,
                    user_id: userId,
                    commands: commands
                })
            })
                .then(r => r.json())
                .then(d => {
                    if (d.status === 'success') {
                        showToast("Settings saved & Bot restarting...");
                        closeDiscordSettings();
                        updateDeclaredCommandsCache();
                    } else {
                        showToast("Error saving: " + d.message, 'error');
                    }
                })
                .catch(e => showToast("Error: " + e, 'error'));
        }
    </script>
    </script>
</body>

</html>